S1b <- S1[3:4, 3:4]
S2a <- S2[1:2, 1:2]
S2b <- S2[3:4, 3:4]
MVMA2a <- solve(solve(S1a)+solve(S2a))
UVMA2a <- solve(solve(U1a)+solve(U2a)) %*%
(solve(U1a) %*% S1a %*% solve(U1a) + solve(U2a) %*% S2a %*% solve(U2a)) %*%
solve(solve(U1a)+solve(U2a))
MVMA2b <- solve(solve(S1b)+solve(S2b))
UVMA2b <- solve(solve(U1b)+solve(U2b)) %*%
(solve(U1b) %*% S1b %*% solve(U1b) + solve(U2b) %*% S2b %*% solve(U2b)) %*%
solve(solve(U1b)+solve(U2b))
diag(MVMA4)/diag(UVMA4)
diag(MVMA2a)/diag(UVMA2a)
diag(MVMA2b)/diag(UVMA2b)
S1 <- bdiag(matrix(runif(4,0,0.5),2,2), matrix(runif(4),2,2))
S1 <- as.matrix(S1)
diag(S1) <- 1
S1 <- (S1+t(S1))/2
S2 <- bdiag(matrix(runif(4,0,0.5),2,2), matrix(runif(4),2,2))
S2 <- as.matrix(S2)
diag(S2) <- 1
S2 <- (S2+t(S2))/2
V1 <- diag(c(0.2,0.4,0.6,0.8))
V2 <- diag(c(0.1,0.3,0.5,0.7))
S1 <- sqrt(V1) %*% S1 %*% sqrt(V1)
S2 <- sqrt(V2) %*% S2 %*% sqrt(V2)
U1 <- diag(diag(S1))
U2 <- diag(diag(S2))
MVMA4 <- solve(solve(S1)+solve(S2))
UVMA4 <- solve(solve(U1)+solve(U2)) %*%
(solve(U1) %*% S1 %*% solve(U1) + solve(U2) %*% S2 %*% solve(U2)) %*%
solve(solve(U1)+solve(U2))
U1a <- diag(diag(S1a))
U1b <- diag(diag(S1b))
U2a <- diag(diag(S2a))
U2b <- diag(diag(S2b))
S1a <- S1[1:2, 1:2]
S1b <- S1[3:4, 3:4]
S2a <- S2[1:2, 1:2]
S2b <- S2[3:4, 3:4]
MVMA2a <- solve(solve(S1a)+solve(S2a))
UVMA2a <- solve(solve(U1a)+solve(U2a)) %*%
(solve(U1a) %*% S1a %*% solve(U1a) + solve(U2a) %*% S2a %*% solve(U2a)) %*%
solve(solve(U1a)+solve(U2a))
MVMA2b <- solve(solve(S1b)+solve(S2b))
UVMA2b <- solve(solve(U1b)+solve(U2b)) %*%
(solve(U1b) %*% S1b %*% solve(U1b) + solve(U2b) %*% S2b %*% solve(U2b)) %*%
solve(solve(U1b)+solve(U2b))
diag(MVMA4)/diag(UVMA4)
diag(MVMA2a)/diag(UVMA2a)
diag(MVMA2b)/diag(UVMA2b)
S1 <- r*ARMAcor(phi=rho1, rho=1, n=p)
S1
S1 <- S2 <- diag(rep(1,p))
S1
S1 <- r*S1
S2 <- (1-r)*S2
library(dplyr)
library(glmnet)
install.packages(c("ROCR","glmnet"))
library(CancerMutationAnalysis)
data(WoodBreast07)
ls()
BackRatesBreast
dim(BackRatesBreast)
golf <- read.table("http://www.stat.ufl.edu/~winner/data/pgalpga2008.dat")
colnames(golf) <- c("AvDrive", "Acc", "Sex")
pairs(golf)
golfM <- golf[golf$Sex==2,]
golfF <- golf[golf$Sex==1,]
plot(golfM$Acc ~ golfM$AvDrive)
plot(golfF$Acc ~ golfF$AvDrive)
summary(lm(Acc ~ AvDrive, data=golfF))
?predict
predict(lm(Acc ~ AvDrive, data=golfF), newdata=260, interval="prediction")
predict(lm(Acc ~ AvDrive, data=golfF), newdata=data.frame(AvDrive=260),
interval="prediction")
130.89331-0.25649*260
golf$Sex <- golf$Sex-1
fit <- lm(Acc ~ AvDrive + Sex, data=golfF)
summary(fit)
table(golf$Sex)
fit <- lm(Acc ~ AvDrive + Sex, data=golf)
summary(fit)
plot(fitted(fit), residuals(fit))
ls()
set.seed(1)
rchisq(10, 1)
set.seed(1)
rgamma(10, 1/2, 1/2)
set.seed(1)
rchisq(10, 1) * 5
set.seed(1)
rgamma(10, 1/2, 5/2)
rgamma(10, 1/2, 1/10)
rgamma(10, 1/2, 1/2/sqrt(5))
set.seed(1)
rgamma(10, 1/2, 1/2/sqrt(5))
library(qvalur)
library(qvalue)
?qvalue
library(swfdr)
calculateSwfdr
swfdr::calculateSwfd
swfdr::calculateSwfdr
setwd("~/GitHub/swfdr/R")
getwd("..")
setwd("..")
getwd()
10^-10
?message
devtools::build_vignettes()
devtools::build_vignettes()
roxygen2::roxygenise()
devtools::build_vignettes()
devtools::clean_vignettes()
library(swfdr)
calculateSwfdr()
calculateSwfdr
devtools::build_vignettes()
source("https://bioconductor.org/biocLite.R")
biocLite("BiocCheck")
library(BiocCheck)
BiocCheck("../swfdr/")
BiocCheck("")
BiocCheck()
?BiocCheck
library(swfdr)
browseVignettes("swfdr")
library(swfdr)
pVals <- runif(100)
tt <- rr <- rep(0, 100)
resSwfdr <- calculateSwfdr(pValues = pVals, truncated = tt, rounded = rr, numEmIterations=100)
resSwfdr
getwd()
roxygen2::roxygenise()
devtools::build_vignettes()
devtools::clean_vignettes()
devtools::build_vignettes()
roxygen2::roxygenise()
?iris
devtools::clean_vignettes()
devtools::build_vignettes()
install.packages("knitr")
install.packages(c("genefilter","lme4","reshape2"))
source("https://bioconductor.org/biocLite.R")
biocLite("genefilter")
install.packages(c("ggplot2"))
install.packages("rmarkdown")
help(packages="genefilter")
packages(help="genefilter")
help(library="genefilter")
library(help="genefilter")
roxygen2::roxygenise()
install.packages("roxygen2")
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
"BMI_GIANT_GWAS_sample"
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
devtools::document()
install.packages("devtools")
devtools::document()
?importFrom
library(stats4)
?mle
roxygen2::roxygenize()
roxygen2::roxygenize()
devtools::clean_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
roxygen2::roxygenize()
?iris
library(swfdr)
?BMI_GIANT_GWAS_sample
devtools::build_vignettes()
devtools::document()
?iris
?mle
devtools::document()
?iris
BMI_GIANT_GWAS_sample
journals_pVals
class(BMI_GIANT_GWAS_sample)
journals_pVals(BMI_GIANT_GWAS_sample)
class(journals_pVals)
?tbl_df
??tbl_df
devtools::document()
install.packages("dplyr")
devtools::document()
devtools::clean_vignettes()
class(BMI_GIANT_GWAS_sample)
devtools::document()
devtools::clean_vignettes()
devtools::build_vignettes()
devtools::clean_vignettes()
devtools::build_vignettes()
?filter
devtools::clean_vignettes()
devtools::build_vignettes()
load("~/GitHub/swfdr/data/journals_pVals.RData")
devtools::build_vignettes()
journals_pVals1 <- dplyr::filter(journals_pVals,
year == 2005,
journal == "American Journal of Epidemiology",
pvalue < 0.05)
dim(journals_pVals1)
tt <- journals_pVals1[,2]
rr <- rep(0,length(tt))
rr[tt == 0] <- (journals_pVals1[tt==0,1] == round(journals_pVals1[tt==0,1],2))
pVals <- journals_pVals1[,1]
resSwfdr <- calculateSwfdr(pValues = pVals, truncated = tt, rounded = rr, numEmIterations=100)
tt
class(tt)
tt <- journals_pVals1[,2,drop=TRUE]
class(tt)
tt <- data.frame(journals_pVals1)[,2]
tt
tt <- data.frame(journals_pVals1)[,2]
rr <- rep(0,length(tt))
rr[tt == 0] <- (data.frame(journals_pVals1)[tt==0,1] ==
round(data.frame(journals_pVals1)[tt==0,1],2))
pVals <- data.frame(journals_pVals1)[,1]
resSwfdr <- calculateSwfdr(pValues = pVals, truncated = tt, rounded = rr, numEmIterations=100)
names(resSwfdr)
devtools::clean_vignettes()
devtools::build_vignettes()
library(BiocCheck)
library(Biocheck)
source("https://bioconductor.org/biocLite.R")
biocLite("BiocCheck")
library(BiocCheck)
devtools::clean_vignettes()
library(devtools)
?clean_vignettes
r Sys.Date()
Sys.Date()
journals_pVals1 <- dplyr::filter(journals_pVals,
year == 2005,
journal == "American Journal of Epidemiology",
pvalue < 0.05)
?doc_date
??doc_date
devtools::build_vignettes()
devtools::clean_vignettes()
?save
devtools::document()
devtools::document()
library(swfdr)
journals_pVals
library(splines)
tme <- seq(0,1,by=0.1)
tme
splineMat <- ns(tme,df=3)
head(splineMat)
solve(t(splineMat)%*%splineMat)
setwd("~/GitHub/Fdr-regression/Simulations - independent")
load("simResults_pi0x_thresh_1.RData")
ls()
rm(list=ls())
load("simResults_pi0x_thresh_1.RData")
load("simResults_pi0x_thresh_1.RData")
ls()
dim(pi0EstSim[[1]])
class(pi0EstSim[[1]])
names(pi0EstSim[[1]])
length(pi0EstSim[[1]])
pi0EstSim[[1]][[1]]
pi0hat0.8 <- sapply(pi0EstSim, function(x){x[[1]]})
dim(pi0hat0.8)
pi0hat0.9 <- sapply(pi0EstSim, function(x){x[[2]]})
pi0hatFinal <- sapply(pi0EstSim, function(x){x[[3]]})
dim(pi0hat0.8)
dim(pi0hat0.9)
dim(pi0hatFinal)
pi0hatMean0.8 <- rowMeans(pi0hat0.8)
length(pi0hatMean0.8)
length(pi0hatMean0.9)
pi0hatMean0.9 <- rowMeans(pi0hat0.9)
pi0hatMeanFinal <- rowMeans(pi0hatFinal)
tme <- seq(-1,2,length=ntest)
tme <- seq(-1,2,length=length(pi0hatMean0.8))
pi0 <- 1/4*tme+1/2
par(cex.axis = 1.1, cex.main=1.3,
mar=c(5.1, 4.1, 4.1, 14.6), xpd=TRUE)
plot(pi0 ~ tme,col="black",type="l",lwd=8, lty=1,
xlab="", yaxt = "n",
ylim=c(0,1), ylab="")
mtext(expression(x[i]), 1, line=3, cex=1.3)
mtext(expression(paste("Mean ", hat(pi)[0](x[i])," and ", pi[0](x[i]))), 2, line=2, cex=1.3)
points(pi0hatMean0.8 ~ tme,col="orange",type="l",lwd=2, lty=3)
points(pi0hatMean0.9 ~ tme,col="orange",type="l",lwd=2, lty=2)
points(pi0hatMeanFinal ~ tme,col="orange",type="l",lwd=3, lty=1)
points(pi0hatScottMean ~ tme,col="blue",type="l",lwd=3, lty=1)
legend("topright", inset=c(-0.71,0),
legend=c("Truth", expression(paste("SLR (", lambda, "=0.8)")),
expression(paste("SLR (", lambda, "=0.9)")),
"SLR (smoothed)", "SLR (Scott)"),
col=c("black", "orange", "orange", "orange", "blue"), bty="n",
lwd=c(8,2,2,3,3), lty=c(1,3,2,1,1),
cex=1.2, x.intersp=0.2, y.intersp=1.0)
axis(side=2, at=(0:5)/5, mgp=c(3, 0.7, 0))
pi0hatVar0.8 <- apply(pi0hat0.8,1,var)
length(pi0hatVar0.8)
plot(pi0hatVar0.8~tme)
load("simResults_pi0x_noThresh_1.RData")
ls()
par(cex.axis = 1.1, cex.main=1.3,
mar=c(5.1, 4.1, 4.1, 14.6), xpd=TRUE)
plot(pi0 ~ tme,col="black",type="l",lwd=8, lty=1,
xlab="", yaxt = "n",
ylim=c(0,1), ylab="")
mtext(expression(x[i]), 1, line=3, cex=1.3)
mtext(expression(paste("Mean ", hat(pi)[0](x[i])," and ", pi[0](x[i]))), 2, line=2, cex=1.3)
points(pi0hatMean0.8 ~ tme,col="orange",type="l",lwd=2, lty=3)
points(pi0hatMean0.9 ~ tme,col="orange",type="l",lwd=2, lty=2)
points(pi0hatMeanFinal ~ tme,col="orange",type="l",lwd=3, lty=1)
points(pi0hatScottMean ~ tme,col="blue",type="l",lwd=3, lty=1)
rm(list=ls())
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenize()
library(roxygen2)
roxygenize()
devtools::use_data()
help(package="devtools")
roxygen2::roxygenize()
library(powerEpiSurv)
library(powEpiSurv)
library(pwrEpiSurv)
library(powerSurvEpi)
library(roxygen2)
devtools::install_github("klutometis/roxygen")
library(roxygen2)
devtools::install_github("klutometis/roxygen")
library(roxygen2)
install.packages("roxygen2")
library(roxygen2)
install.packages("stringi")
library(roxygen2)
install.packages("stringi")
library(roxygen2)
library(roxygen2)
roxygen2::document()
??document
getwd()
document()
devtools::document()
?devtools::use_vignette
devtools::use_vignette("vignettes/swfdrTutorial")
devtools::use_vignette("swfdrTutorial")
?devtools::build_vignettes()
?devtools::build_vignettes
devtools::build_vignettes()
install.packges("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build()
devtools::clean_vignettes()
devtools::build()
?check
devtools::check_built()
devtools::check_built(".")
devtools::build()
devtools::check_built(".")
library(swfdr)
#' Estimate pi0(x)
#'
#' @param pValues Numerical vector of p-values
#' @param lambda Numerical vector of thresholds. Must be in [0,1).
#' @param X Design matrix (one test per row, one variable per column). Do not include the intercept.
#' @param type Type of regression, "logistic" or "linear." Default is logistic.
#' @param smooth.df Number of degrees of freedom when estimating pi0(x) with a smoother.
#' @param threshold If TRUE (default), all estimates are thresholded at 0 and 1, if FALSE, none of them are.
#'
#' @return pi0 Numerical vector of smoothed estimate of pi0(x). The length is the number of rows in X.
#' @return pi0.lambda Numerical matrix of estimated pi0(x) for each value of lambda. The number of columns is the number of tests, the number of rows is the length of lambda.
#' @return lambda Vector of the values of lambda used in calculating pi0.lambda
#' @return pi0.smooth Matrix of fitted values from the smoother fit to the pi0(x) estimates at each value of lambda (same number of rows and columns as pi0.lambda)
#'
#' @import ggplot2
#' @import reshape2
#'
#' @examples
#' X <- seq(-1,2,length=1000) ##covariate
#' pi0 <- 1/4*X + 1/2 ##probability of being null
#' nullI <- rbinom(1000,prob=pi0,size=1)> 0 ##generate null/alternative p-values
#' pValues <- rep(NA,1000) ##vector of p-values
#' pValues[nullI] <- runif(sum(nullI)) ##null from U(0,1)
#' pValues[!nullI] <- rbeta(sum(!nullI),1,2) ##alternative from Beta
#' pi0x <- lm_pi0(pValues=pValues, X=X, smooth.df=3)
#'
#' @export
lm_pi0 <- function(pValues, lambda = seq(0.05, 0.95, 0.05), X, type="logistic", smooth.df=3, threshold=TRUE)
{
##if X is a vector, change it into a matrix
if(is.null(dim(X)))
{
X <- matrix(X, ncol=1)
}
##number of tests
n <- nrow(X)
##number of lambdas
nLambda <- length(lambda)
##sort lambdas from smallest to largest and take only unique values
lambda <- sort(unique(lambda))
##make a design matrix with the intercept
Xint <- cbind(1, X)
##get the estimate for each value of lambda
pi0.lambda <- matrix(NA, nrow=n, ncol=nLambda)
for(i in 1:nLambda)
{
lambda.i <- lambda[i]
y <- pValues > lambda.i
if(tolower(type)=="logistic"){
##fit regression
regFit <- glm(y ~ X, family=binomial)
##get the estimated values of pi0
pi0.lambda[,i] <- regFit$fitted.values/(1-lambda.i)
} else {
if(tolower(type)=="linear")
{
##fit regression
regFit <- lsfit(X, y)
##get the estimated values of pi0
pi0.lambda[,i] <- (Xint %*% matrix(regFit$coefficients, ncol=1))[,1]/(1-lambda.i)
}
}
if(threshold){
pi0.lambda[,i] <- ifelse(pi0.lambda[,i] > 1, 1, pi0.lambda[,i])
pi0.lambda[,i] <- ifelse(pi0.lambda[,i] < 0, 0, pi0.lambda[,i])
}
}
##smooth over values of lambda (do this for each test in part)
pi0.smooth <- matrix(NA, nrow=n, ncol=nLambda)
##also save final estimate (maximum of 0 and minimum of 1 and smoothed value at largest lambda)
pi0 <- rep(NA, length=n)
for(i in 1:n)
{
if(i %% 10000==0)
{
message(paste("At test #:",i))
}
spi0 <- smooth.spline(lambda, pi0.lambda[i,], df=smooth.df)
pi0.smooth[i, ] <- spi0$y
pi0[i] <- pi0.smooth[i,nLambda]
}
if(threshold){
pi0 <- ifelse(pi0 > 1, 1, pi0)
pi0 <- ifelse(pi0 < 0, 0, pi0)
}
return(list(pi0=pi0, pi0.lambda=pi0.lambda, lambda=lambda, pi0.smooth=pi0.smooth))
}
X <- seq(-1,2,length=1000) ##covariate
pi0 <- 1/4*X + 1/2 ##probability of being null
nullI <- rbinom(1000,prob=pi0,size=1)> 0 ##generate null/alternative p-values
pValues <- rep(NA,1000) ##vector of p-values
pValues[nullI] <- runif(sum(nullI)) ##null from U(0,1)
pValues[!nullI] <- rbeta(sum(!nullI),1,2) ##alternative from Beta
pi0x <- lm_pi0(pValues=pValues, X=X, smooth.df=3)
head(pi0x)
length(pi0x)
dim(pi0x)
dim(pi0x[[1]])
length(pi0x[[1]])
names(pi0x)
head(pi0x$pi0.smooth)
pi0x$pi0.smooth[1:5,1:]
pi0x$pi0.smooth[1:5,1:6]
pi0x <- lm_pi0(pValues=pValues, X=X, smooth.df=3, type="linear")
pi0x_log <- lm_pi0(pValues=pValues, X=X, smooth.df=3, type="logistic")
pi0x$pi0.smooth[1:5,1:6]
pi0x_log$pi0.smooth[1:5,1:6]
cor(pi0x$pi0.smooth[,1], pi0x_log$pi0.smooth[,1])
cor(pi0x$pi0.smooth[,2], pi0x_log$pi0.smooth[,2])
cor(pi0x$pi0.smooth[,3], pi0x_log$pi0.smooth[,3])
cor(pi0x$pi0.smooth[,4], pi0x_log$pi0.smooth[,4])
dim(pi0x$pi0.lambda)
cor(pi0x$pi0.smooth[,19], pi0x_log$pi0.smooth[,19])
devtools::build_vignettes()
?build_vignettes
devtools::build_vignettes()
devtools::build()
